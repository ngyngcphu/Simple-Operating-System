<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Simple Operating System</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="scheduler/index.html"><strong aria-hidden="true">1.</strong> Scheduler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scheduler/implement.html"><strong aria-hidden="true">1.1.</strong> Implement</a></li><li class="chapter-item expanded "><a href="scheduler/result.html"><strong aria-hidden="true">1.2.</strong> Result</a></li></ol></li><li class="chapter-item expanded "><a href="memory/index.html"><strong aria-hidden="true">2.</strong> Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="memory/implement.html"><strong aria-hidden="true">2.1.</strong> Implement</a></li><li class="chapter-item expanded "><a href="memory/result.html"><strong aria-hidden="true">2.2.</strong> Result</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Simple Operating System</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="scheduler"><a class="header" href="#scheduler">Scheduler</a></h1>
<h2 id="i-giải-thuật-sử-dụng"><a class="header" href="#i-giải-thuật-sử-dụng">I. Giải thuật sử dụng</a></h2>
<pre><code>Multi-Level Queue (MFQ)
</code></pre>
<h2 id="ii-mô-tả-giải-thuật"><a class="header" href="#ii-mô-tả-giải-thuật">II. Mô tả giải thuật</a></h2>
<ul>
<li>Mỗi process với cùng độ ưu tiên sẽ được đặt vào cùng một hàng đợi ready-queue.</li>
<li><strong>MLQ policy</strong>: Khi hàng đợi P thực hiện đủ số lần slot (slot = MAX_PRIORITY - prio) thì tạm dừng, chuyển thực thi cho hàng đợi Q có ưu tiên thấp hơn. Khi các hàng đợi có độ ưu tiên thấp đã thực hiện hết số lần slot cho phép sẽ quay lại lần lặp kế tiếp với P là hàng đợi có độ ưu tiên cao được thực thi trước với số lần slot được tính.</li>
<li>CPU thực thi mỗi process theo RR-style. Sau khi hết time slice, process được đưa vào cuối hàng đợi với độ ưu tiên như cũ. CPU tiếp tục chọn process theo <strong>MLQ policy</strong> để thực thi.</li>
</ul>
<h2 id="iii-so-sánh-với-các-giải-thuật-scheduler-khác"><a class="header" href="#iii-so-sánh-với-các-giải-thuật-scheduler-khác">III. So sánh với các giải thuật scheduler khác</a></h2>
<p>Nhược điểm của các giải thuật khác:</p>
<ul>
<li>FCFS: CPU phải thực thi 1 process liên tục cho đến khi kết thúc -&gt; tăng waiting time đối với các process có CPU burst ngắn. </li>
<li>SJF: Không thể biết chính xác CPU time của process kế tiếp, có khả năng gây ra starvation.</li>
<li>RR: Time slice lớn -&gt; FCFS. Time slice nhỏ -&gt; context switch.</li>
<li>PS-normal: có khả năng gây ra starvation.</li>
</ul>
<p>Ưu điểm của MFQ:</p>
<ul>
<li>Response time: Các process có độ ưu tiên cao được thực thi trước.</li>
<li>Not starvation: Mỗi ready-queue có số lần slot nhất định trong chu kì thực thi của các hàng đợi.</li>
<li>Fairly: Giải thuật cho mỗi hàng đợi là Round Robin.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="iv-triển-khai"><a class="header" href="#iv-triển-khai">IV. Triển khai</a></h2>
<ol>
<li>Priority Queue
<ul>
<li><code>void enqueue(struct queue_t *q, struct pcb_t *proc)</code>: Thêm 1 process proc vào cuối hàng đợi q.</li>
<li><code>struct pcb_t *dequeue(struct queue_t *q)</code>: Lấy 1 process từ đầu hàng đợi q.</li>
</ul>
</li>
<li>Scheduler
<ul>
<li><code>struct pcb_t *get_mlq_proc(void)</code>: Lấy 1 process từ ready-queue theo <strong>MLQ policy</strong>, sử dụng khóa mutex để bảo vệ hàng đợi.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="v-kết-quả"><a class="header" href="#v-kết-quả">V. Kết quả</a></h2>
<ol>
<li>TEST 1:</li>
</ol>
<ul>
<li>Input</li>
</ul>
<table>
<tr>
<td>
<pre><code>sched:
4 2 3
0 p1s 1
1 p2s 0
2 p3s 0
</code></pre>
</td>
<td>
<pre><code>p1s:
1 10
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
<td>
<pre><code>p2s:
20 12
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
<td>
<pre><code>p3s:
7 11
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
</tr>
</table>
<ul>
<li>Output: Kết quả chi tiết trong <code>/output/sched.output</code>.<br />
Gantt diagram:<br />
<img src="scheduler/../assets/sched.png" alt="sched" /></li>
</ul>
<ol start="2">
<li>TEST 2:</li>
</ol>
<ul>
<li>Input</li>
</ul>
<table>
<tr>
<td>
<pre><code>sched_0:
2 1 2
0 s0 4
4 s1 0
</code></pre>
</td>
<td>
<pre><code>s0:
12 15
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
<td>
<pre><code>s1:
20 7
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
</tr>
</table>
<ul>
<li>Output: Kết quả chi tiết trong <code>/output/sched_0.output</code>.<br />
Gantt diagram:<br />
<img src="scheduler/../assets/sched_0.png" alt="sched" /></li>
</ul>
<ol start="3">
<li>TEST 3:</li>
</ol>
<ul>
<li>Input</li>
</ul>
<table>
<tr>
<td>
<pre><code>sched_1:
2 1 4
0 s0 4
4 s1 0
6 s2 0
7 s3 0
</code></pre>
</td>
<td>
<pre><code>s0:
12 15
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
<td>
<pre><code>s1:
20 7
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
<td>
<pre><code>s2:
20 12
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
<td>
<pre><code>s3:
7 11
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
</tr>
</table>
<ul>
<li>Output: Kết quả chi tiết trong <code>/output/sched_1.output</code>.<br />
Gantt diagram:<br />
<img src="scheduler/../assets/sched_1.png" alt="sched" /></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<h2 id="i-các-modules-trong-memory-system"><a class="header" href="#i-các-modules-trong-memory-system">I. Các modules trong memory system</a></h2>
<p><img src="memory/../assets/mod-mem.png" alt="Memory-Modules" /></p>
<h3 id="1-mm-vm-virtual-memory"><a class="header" href="#1-mm-vm-virtual-memory">1. MM-VM Virtual Memory</a></h3>
<ul>
<li>Không gian địa chỉ bộ nhớ ảo bao gồm:
<ul>
<li>Memory Area (mỗi area đại diện cho các segment của 1 process: data segment, code segment, stack segment, heap segment,...). Trong Assignment, ta chỉ sử dụng 1 memory area tương ứng vmaid = 0. </li>
<li>Mỗi Memory Area bao gồm các Memory Region (region đang được sử dụng và region đang free).</li>
</ul>
</li>
<li>Lợi ích của việc thiết kế multiple segments:
<ul>
<li>Tổ chức bộ nhớ tốt hơn, dễ dàng quản lý và truy xuất dữ liệu: Stack segment quản lý các local variables và các function calls, Heap segment quản lý việc cấp phát động, Code segment quản lý các câu lệnh được thực thi,...</li>
<li>Giảm context switching: Khi CPU switch giữa các processes hoặc threads, chỉ những segments cần thiết mới được restore trở lại CPU để tiếp tục thực thi. Điều này hiệu quả và nhanh hơn thay vì restore toàn bộ không gian địa chỉ.</li>
</ul>
</li>
<li>Các operations trên virtual memory bao gồm:
<ul>
<li><code>ALLOC</code>: cấp phát 1 region memory.</li>
<li><code>FREE</code>: giải phóng 1 region memory.</li>
<li><code>READ</code>: đọc 1 byte giá trị tại 1 ô nhớ trong region memory.</li>
<li><code>WRITE</code>: viết 1 byte giá trị vào 1 ô nhớ trong region memory.</li>
</ul>
</li>
</ul>
<h3 id="2-mm-memory-management"><a class="header" href="#2-mm-memory-management">2. MM-Memory Management</a></h3>
<ul>
<li>Mỗi process có 1 module Memory Management với vai trò mapping virtual address sang physical address, cụ thể:
<ul>
<li>Giữ địa chỉ page table directory của process. Page table sẽ ánh xạ mỗi logical address sang page table entry.</li>
<li>Quản lý địa chỉ các virtual memory area (segment) của process.</li>
<li>Quản lý các memory region đang được sử dụng của process.</li>
<li>Quản lý danh sách các page được map với frame trong physical memory theo cơ chế FIFO.</li>
</ul>
</li>
<li>Memory Management quản lý logical address theo cơ chế paging (mỗi page là một không gian địa chỉ với kích thước cố định). Cấu trúc logical address 22 bit trong assignment được chia thành 2 mức, bao gồm 14 bit page number và 8 bit page offset.</li>
<li>Có những lợi ích và bất lợi nếu chia logical address nhiều hơn 2 mức:
<ul>
<li>Giảm thiểu memory overhead: Thay vì sử dụng một page table duy nhất, ta có thể sử dụng nhiều page table nhỏ hơn, chỉ những page table được sử dụng mới được load vào physical address.</li>
<li>Đối với các hệ thống lớn (64-bit), việc chia logical address thành nhiều mức sẽ giúp giảm thiểu memory overhead nhưng lại khó quản lý nên cũng không mang lại hiệu quả.</li>
</ul>
</li>
<li>Lợi ích và bất lợi của segmentation with paging:
<ol>
<li>Lợi ích:
<ul>
<li>Quản lý các segment với các page hiệu quả hơn so với việc quản lý từng địa chỉ.</li>
<li>Tránh external fragmentation.</li>
</ul>
</li>
<li>Bất lợi:
<ul>
<li>Internal fragmentation vẫn xảy ra vì kích thước trang là cố định.</li>
<li>Tăng độ phức tạp của việc quản lý.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-memphy-memory-physical"><a class="header" href="#3-memphy-memory-physical">3. MEMPHY-Memory Physical</a></h3>
<ul>
<li>Không gian địa chỉ bộ nhớ vật lý bao gồm:
<ul>
<li>RAM: Bộ nhớ chính, có thể được truy xuất trực tiếp bởi CPU.</li>
<li>SWAP: Bộ nhớ thứ cấp, không được truy xuất trực tiếp bởi CPU, kích thước lớn hơn RAM và số lượng nhiều (assignment dùng 4 SWAP).</li>
</ul>
</li>
<li>Các opearions trên physical memory bao gồm:
<ul>
<li><code>READ</code>: directly đối với RAM và sequentially đối với SWAP.</li>
<li><code>WRITE</code>: directly đối với RAM và sequentially đối với SWAP.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ii-triển-khai"><a class="header" href="#ii-triển-khai">II. Triển khai</a></h2>
<ul>
<li><code>ALLOC</code>
<ul>
<li>
<pre><code class="language-c">  int find_victim_page(struct mm_struct *mm, int *retpgn)
</code></pre>
Tìm một &quot;victim&quot; page trong virtual memory:
<ul>
<li>Lấy một page từ cuối hàng đợi <code>fifo_pgn</code> mà <code>mm</code> đang quản lý, lưu số thứ tự của page đó vào <code>retpgn</code>.</li>
</ul>
</li>
<li>
<pre><code class="language-c">  int alloc_pages_range(struct pcb_t *caller, int req_pgnum, struct framephy_struct **frm_lst)
</code></pre>
Cấp phát các frame trên RAM và lưu trong danh sách <code>frm_lst</code>:
<ul>
<li>Lặp qua <code>req_pgnum</code> lần. Ở mỗi bước lặp, kiểm tra có thể cấp phát 1 frame trong RAM. Nếu được, thêm frame vừa được cấp phát vào đầu danh sách <code>frm_lst</code>. Nếu không, thực thi bước kế tiếp.</li>
<li>Tìm một frame <code>vicfpn</code> trong RAM và thay thế nó bằng một free frame <code>swpfpn</code> trong SWAP. Việc lựa chọn một <code>vicfpn</code> cần tìm một &quot;victim&quot; page <code>vicpgn</code> trong virtual memory bằng hàm <code>find_victim_page</code>.</li>
<li>Nếu việc tìm <code>vicpgn</code> hoặc lấy một <code>swpfpn</code> trong SWAP thất bại thì giải phóng toàn bộ các frame đã được cấp phát trước đó và trả về lỗi.</li>
<li>Swap <code>vicfpn</code> trong RAM với <code>swpfpn</code> trong SWAP.</li>
<li>Set page table entry tương ứng với <code>vicpgn</code> bằng hàm <code>pte_set_swap</code>, thêm <code>swpfpn</code> vào đầu danh sách <code>frm_lst</code>.</li>
</ul>
</li>
<li>
<pre><code class="language-c">  int vmap_page_range(struct pcb_t *caller, int addr, int pgnum, struct framephy_struct *frames, struct vm_rg_struct *ret_rg)
</code></pre>
Mapping các page tại địa chỉ <code>addr</code> với các frame trong danh sách <code>frames</code>:
<ul>
<li>Duyệt qua các page, set frame page table entry tương ứng với các page bằng hàm <code>pte_set_fpn</code>. Sau đó chèn các page đó theo thứ tự vào đầu danh sách <code>fifo_pgn</code>.</li>
</ul>
</li>
<li>
<pre><code class="language-c">  int vm_map_ram(struct pcb_t *caller, int astart, int aend, int mapstart, int incpgnum, struct vm_rg_struct *ret_rg)
</code></pre>
Mapping virtual memory có kích thước <code>aend - astart</code> với RAM:
<ul>
<li>Cấp phát trên RAM số lượng frame bằng với số page <code>incpgnum</code> trên virtual memory bằng hàm <code>alloc_pages_range</code>, lưu các frame sau khi cấp phát thành một danh sách <code>frm_lst</code>.</li>
<li>Nếu cấp phát thành công, map các page tại địa chỉ <code>mapstart</code> với các frame trong danh sách <code>frm_lst</code> bằng hàm <code>vmap_page_range</code>.</li>
</ul>
</li>
<li>
<pre><code class="language-c">  int inc_vma_limit(struct pcb_t *caller, int vmaid, int inc_sz)
</code></pre>
Tăng kích thước vùng nhớ của <code>vmaid</code> lên một khoảng bằng <code>inc_sz</code>:
<ul>
<li>Kiểm tra <code>vmaid</code> nếu tăng kích thước có bị tràn qua các vmaid lân cận. Nếu có, trả về lỗi (return -1), ngược lại thực thi bước kế tiếp.</li>
<li>Dịch con trỏ <code>sbrk</code> và <code>vm_end</code> của <code>vmaid</code> lên thêm 1 khoảng bằng <code>inc_sz</code>.</li>
<li>Tiến hành mapping virtual memory vừa được cấp phát sang physical memory trên RAM bằng hàm <code>vm_map_ram</code>.</li>
</ul>
</li>
<li>
<pre><code class="language-c">  int __alloc(struct pcb_t *caller, int vmaid, int rgid, int size, int *alloc_addr)
</code></pre>
Cấp phát cho region <code>rgid</code> một vùng nhớ với kích thước <code>size</code>, sử dụng khóa mutex để bảo vệ virtual memory:
<ul>
<li>Nếu kích thước vùng nhớ trống của area <code>vmaid &gt;= size</code> thì cấp phát thành công.</li>
<li>Nếu không đủ vùng nhớ, tăng kích thước của area <code>vmaid</code> lên một khoảng bằng số lượng page vừa đủ chứa <code>size</code> bằng hàm <code>inc_vma_limit</code>.</li>
<li>Sau khi tăng kích thước thành công, cấp phát <code>size</code> cho <code>rgid</code>.</li>
<li>Thêm fragment do paging gây ra sau khi cấp phát (nếu có) vào danh sách <code>vm_freerg_list</code> của <code>mm</code>.</li>
</ul>
</li>
<li>
<pre><code class="language-c">  int pgalloc(struct pcb_t *proc, uint32_t size, uint32_t reg_index)
</code></pre>
Thực thi hàm <code>__alloc</code> với <code>vmaid = 0</code> và ghi kết quả vào file output.</li>
</ul>
</li>
<li><code>FREE</code>
<ul>
<li>
<pre><code class="language-c">  int __free(struct pcb_t *caller, int vmaid, int rgid)
</code></pre>
Giải phóng vùng nhớ <code>rgid</code>, sử dụng khóa mutex để bảo vệ virtual memory:
<ul>
<li>Nếu <code>rgid &lt; 0</code> hoặc <code>rgid &gt; PAGING_MAX_SYMTBL_SZ</code> hoặc <code> size rgid = 0</code>, trả về lỗi (return -1).</li>
<li>Gán kích thước của vùng nhớ <code>rgid</code> bằng 0, thêm vùng nhớ vừa được giải phóng vào danh sách <code>vm_freerg_list</code> mà <code>mm</code> quản lý.</li>
</ul>
</li>
<li>
<pre><code class="language-c">  int pgfree_data(struct pcb_t *proc, uint32_t reg_index)
</code></pre>
Thực thi hàm <code>__free</code> với <code>vmaid = 0</code> và ghi kết quả vào file output.</li>
</ul>
</li>
<li><code>READ</code>
<ul>
<li>
<pre><code class="language-c">  int pg_getpage(struct mm_struct *mm, int pgn, int *fpn, struct pcb_t *caller)
</code></pre>
<p>Lấy frame <code>fpn</code> tương ứng với page <code>pgn</code>:</p>
<ul>
<li>Nếu frame online (frame đang được lưu trên RAM ), trả về  <code>fpn</code>. Nếu frame offline (frame đang được lưu trên SWAP), thực thi bước kế tiếp.</li>
<li>Tìm 1 &quot;victim&quot; page <code>vicpgn</code> trong virtual memory bằng hàm <code>find_victim_page</code> và lấy 1 free frame <code>swpfpn</code> từ SWAP. Nếu thành công, thực thi bước kế tiếp.</li>
<li>Swap <code>vicfpn</code> tương ứng <code>vicpgn</code> trong RAM với <code>swpfpn</code> trong SWAP.</li>
<li>Swap <code>tgtfpn</code> tương ứng <code>pgn</code> trong SWAP với <code>swpfpn</code> trong RAM.</li>
<li>Set swap page table entry tương ứng với <code>vicpgn</code> bằng hàm <code>pte_set_swap</code>.</li>
<li>Set frame page table entry tương ứng <code>pgn</code> bằng hàm <code>pte_set_fpn</code>.</li>
<li>Thêm <code>pgn</code> vào danh sách <code>fifo_pgn</code> của <code>mm</code>, trả về  <code>fpn</code>.</li>
</ul>
<p>Hình vẽ mô tả:
<img src="memory/../assets/getpage.png" alt="getpage" /></p>
</li>
<li>
<pre><code class="language-c">  int pg_getval(struct mm_struct *mm, int addr, BYTE *data, struct pcb_t *caller)
</code></pre>
<p>Lấy giá trị của ô nhớ tại địa chỉ <code>addr</code> và lưu vào <code>data</code>:</p>
<ul>
<li>Lấy page number và page offset từ <code>addr</code>.</li>
<li>Lấy frame number trong RAM hoặc SWAP tương ứng với page number trong virtual memory bằng hàm <code>pg_getpage</code>.</li>
<li>Nếu thành công, kết hợp frame number và page offset trả về physical memory. Đọc giá trị của địa chỉ vật lý này trong bộ nhớ vật lý bằng hàm <code>MEMPHY_read</code>.</li>
</ul>
</li>
<li>
<pre><code class="language-c">  int __read(struct pcb_t *caller, int vmaid, int rgid, int offset, BYTE *data)
</code></pre>
<p>Thực thi hàm <code>getval</code> để đọc 1 byte giá trị ô nhớ ở vị trí <code>offset</code> trong vùng nhớ <code>rgid</code> vào <code>data</code>, sử dụng khóa mutex để bảo vệ virtual memory.</p>
</li>
<li>
<pre><code class="language-c">  int pgread(struct pcb_t *proc, uint32_t source, uint32_t offset, uint32_t destination)
</code></pre>
<p>Thực thi hàm <code>__read</code> với <code>vmaid = 0</code> và ghi kết quả vào file output.</p>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="iii-kết-quả"><a class="header" href="#iii-kết-quả">III. Kết quả</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
