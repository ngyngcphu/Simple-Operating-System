<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Simple Operating System</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="scheduler/index.html"><strong aria-hidden="true">1.</strong> Scheduler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scheduler/implement.html"><strong aria-hidden="true">1.1.</strong> Implement</a></li><li class="chapter-item expanded "><a href="scheduler/result.html"><strong aria-hidden="true">1.2.</strong> Result</a></li></ol></li><li class="chapter-item expanded "><a href="memory/index.html"><strong aria-hidden="true">2.</strong> Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="memory/implement.html"><strong aria-hidden="true">2.1.</strong> Implement</a></li><li class="chapter-item expanded "><a href="memory/result.html"><strong aria-hidden="true">2.2.</strong> Result</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Simple Operating System</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="scheduler"><a class="header" href="#scheduler">Scheduler</a></h1>
<h2 id="i-giải-thuật-sử-dụng"><a class="header" href="#i-giải-thuật-sử-dụng">I. Giải thuật sử dụng:</a></h2>
<pre><code>Multi-Level Queue (MFQ)
</code></pre>
<h2 id="ii-mô-tả-giải-thuật"><a class="header" href="#ii-mô-tả-giải-thuật">II. Mô tả giải thuật</a></h2>
<ul>
<li>Mỗi process với cùng độ ưu tiên sẽ được đặt vào cùng một hàng đợi ready-queue.</li>
<li><strong>MLQ policy</strong>: Khi hàng đợi P thực hiện đủ số lần slot (slot = MAX_PRIORITY - prio) thì tạm dừng, chuyển thực thi cho hàng đợi Q có ưu tiên thấp hơn. Khi các hàng đợi có độ ưu tiên thấp đã thực hiện hết số lần slot cho phép sẽ quay lại lần lặp kế tiếp với P là hàng đợi có độ ưu tiên cao được thực thi trước với số lần slot được tính.</li>
<li>CPU thực thi mỗi process theo RR-style. Sau khi hết time slice, process được đưa vào cuối hàng đợi với độ ưu tiên như cũ. CPU tiếp tục chọn process theo <strong>MLQ policy</strong> để thực thi.</li>
</ul>
<h2 id="iii-so-sánh-với-các-giải-thuật-scheduler-khác"><a class="header" href="#iii-so-sánh-với-các-giải-thuật-scheduler-khác">III. So sánh với các giải thuật scheduler khác</a></h2>
<p>Nhược điểm của các giải thuật khác:</p>
<ul>
<li>FCFS: CPU phải thực thi 1 process liên tục cho đến khi kết thúc -&gt; tăng waiting time đối với các process có CPU burst ngắn. </li>
<li>SJF: Không thể biết chính xác CPU time của process kế tiếp, có khả năng gây ra starvation.</li>
<li>RR: Time slice lớn -&gt; FCFS. Time slice nhỏ -&gt; context switch.</li>
<li>PS-normal: có khả năng gây ra starvation.</li>
</ul>
<p>Ưu điểm của MFQ:</p>
<ul>
<li>Response time: Các process có độ ưu tiên cao được thực thi trước.</li>
<li>Not starvation: Mỗi ready-queue có số lần slot nhất định trong chu kì thực thi của các hàng đợi.</li>
<li>Fairly: Giải thuật cho mỗi hàng đợi là Round Robin.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="iv-triển-khai"><a class="header" href="#iv-triển-khai">IV. Triển khai</a></h2>
<ol>
<li>Priority Queue
<ul>
<li><code>void enqueue(struct queue_t *q, struct pcb_t *proc)</code>: Thêm 1 process proc vào cuối hàng đợi q.</li>
<li><code>struct pcb_t *dequeue(struct queue_t *q)</code>: Lấy 1 process từ đầu hàng đợi q.</li>
</ul>
</li>
<li>Scheduler
<ul>
<li><code>struct pcb_t *get_mlq_proc(void)</code>: Lấy 1 process từ ready-queue theo <strong>MLQ policy</strong>, sử dụng khóa mutex để bảo vệ hàng đợi.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="v-kết-quả"><a class="header" href="#v-kết-quả">V. Kết quả</a></h2>
<ol>
<li>TEST 1:</li>
</ol>
<ul>
<li>Input</li>
</ul>
<table>
<tr>
<td>
<pre><code>sched:
4 2 3
0 p1s 1
1 p2s 0
2 p3s 0
</code></pre>
</td>
<td>
<pre><code>p1s:
1 10
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
<td>
<pre><code>p2s:
20 12
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
<td>
<pre><code>p3s:
7 11
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
</tr>
</table>
<ul>
<li>Output: Kết quả chi tiết trong <code>/output/sched.output</code>.<br />
Gantt diagram:<br />
<img src="scheduler/../assets/sched.png" alt="sched" /></li>
</ul>
<ol start="2">
<li>TEST 2:</li>
</ol>
<ul>
<li>Input</li>
</ul>
<table>
<tr>
<td>
<pre><code>sched_0:
2 1 2
0 s0 4
4 s1 0
</code></pre>
</td>
<td>
<pre><code>s0:
12 15
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
<td>
<pre><code>s1:
20 7
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
</tr>
</table>
<ul>
<li>Output: Kết quả chi tiết trong <code>/output/sched_0.output</code>.<br />
Gantt diagram:<br />
<img src="scheduler/../assets/sched_0.png" alt="sched" /></li>
</ul>
<ol start="3">
<li>TEST 3:</li>
</ol>
<ul>
<li>Input</li>
</ul>
<table>
<tr>
<td>
<pre><code>sched_1:
2 1 4
0 s0 4
4 s1 0
6 s2 0
7 s3 0
</code></pre>
</td>
<td>
<pre><code>s0:
12 15
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
<td>
<pre><code>s1:
20 7
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
<td>
<pre><code>s2:
20 12
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
<td>
<pre><code>s3:
7 11
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
calc
</code></pre>
</td>
</tr>
</table>
<ul>
<li>Output: Kết quả chi tiết trong <code>/output/sched_1.output</code>.<br />
Gantt diagram:<br />
<img src="scheduler/../assets/sched_1.png" alt="sched" /></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<h2 id="i-các-modules-trong-memory-system"><a class="header" href="#i-các-modules-trong-memory-system">I. Các modules trong memory system</a></h2>
<p><img src="memory/../assets/mod-mem.png" alt="Memory-Modules" /></p>
<h3 id="1-mm-vm-virtual-memory"><a class="header" href="#1-mm-vm-virtual-memory">1. MM-VM Virtual Memory</a></h3>
<ul>
<li>Không gian địa chỉ bộ nhớ ảo bao gồm:
<ul>
<li>Memory Area (mỗi area đại diện cho các segment của 1 process: data segment, code segment, stack segment, heap segment,...). Trong Assignment, ta chỉ sử dụng 1 memory area tương ứng vmaid = 0. </li>
<li>Mỗi Memory Area bao gồm các Memory Region (region đang được sử dụng và region đang free).</li>
</ul>
</li>
<li>Lợi ích của việc thiết kế multiple segments:
<ul>
<li>Tổ chức bộ nhớ tốt hơn, dễ dàng quản lý và truy xuất dữ liệu: Stack segment quản lý các local variables và các function calls, Heap segment quản lý việc cấp phát động, Code segment quản lý các câu lệnh được thực thi,...</li>
<li>Giảm context switching: Khi CPU switch giữa các processes hoặc threads, chỉ những segments cần thiết mới được restore trở lại CPU để tiếp tục thực thi. Điều này hiệu quả và nhanh hơn thay vì restore toàn bộ không gian địa chỉ.</li>
</ul>
</li>
<li>Các operations trên virtual memory bao gồm:
<ul>
<li><code>ALLOC</code>: cấp phát 1 region memory.</li>
<li><code>FREE</code>: giải phóng 1 region memory.</li>
<li><code>READ</code>: đọc 1 byte giá trị tại 1 ô nhớ trong region memory.</li>
<li><code>WRITE</code>: viết 1 byte giá trị vào 1 ô nhớ trong region memory.</li>
</ul>
</li>
</ul>
<h3 id="2-mm-memory-management"><a class="header" href="#2-mm-memory-management">2. MM-Memory Management</a></h3>
<ul>
<li>Mỗi process có 1 module Memory Management với vai trò mapping virtual address sang physical address, cụ thể:
<ul>
<li>Giữ địa chỉ page table directory của process. Page table sẽ ánh xạ mỗi logical address sang page table entry.</li>
<li>Quản lý địa chỉ các virtual memory area (segment) của process.</li>
<li>Quản lý các memory region đang được sử dụng của process.</li>
<li>Quản lý danh sách các page được map với frame trong physical memory theo cơ chế FIFO.</li>
</ul>
</li>
<li>Memory Management quản lý logical address theo cơ chế paging (mỗi page là một không gian địa chỉ với kích thước cố định). Cấu trúc logical address 22 bit trong assignment được chia thành 2 mức, bao gồm 14 bit page number và 8 bit page offset.</li>
<li>Có những lợi ích và bất lợi nếu chia logical address nhiều hơn 2 mức:
<ul>
<li>Giảm thiểu memory overhead: Thay vì sử dụng một page table duy nhất, ta có thể sử dụng nhiều page table nhỏ hơn, chỉ những page table được sử dụng mới được load vào physical address.</li>
<li>Đối với các hệ thống lớn (64-bit), việc chia logical address thành nhiều mức sẽ giúp giảm thiểu memory overhead nhưng lại khó quản lý nên cũng không mang lại hiệu quả.</li>
</ul>
</li>
<li>Lợi ích và bất lợi của segmentation with paging:
<ol>
<li>Lợi ích:
<ul>
<li>Quản lý các segment với các page hiệu quả hơn so với việc quản lý từng địa chỉ.</li>
<li>Tránh external fragmentation.</li>
</ul>
</li>
<li>Bất lợi:
<ul>
<li>Internal fragmentation vẫn xảy ra vì kích thước trang là cố định.</li>
<li>Tăng độ phức tạp của việc quản lý.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-memphy-memory-physical"><a class="header" href="#3-memphy-memory-physical">3. MEMPHY-Memory Physical</a></h3>
<ul>
<li>Không gian địa chỉ bộ nhớ vật lý bao gồm:
<ul>
<li>RAM: Bộ nhớ chính, có thể được truy xuất trực tiếp bởi CPU.</li>
<li>SWAP: Bộ nhớ thứ cấp, không được truy xuất trực tiếp bởi CPU, kích thước lớn hơn RAM và số lượng nhiều (assignment dùng 4 SWAP).</li>
</ul>
</li>
<li>Các opearions trên physical memory bao gồm:
<ul>
<li><code>READ</code>: directly đối với RAM và sequentially đối với SWAP.</li>
<li><code>WRITE</code>: directly đối với RAM và sequentially đối với SWAP.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ii-triển-khai"><a class="header" href="#ii-triển-khai">II. Triển khai</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="iii-kết-quả"><a class="header" href="#iii-kết-quả">III. Kết quả</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
